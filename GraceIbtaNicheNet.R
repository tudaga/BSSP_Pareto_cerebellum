knitr::opts_chunk$set(echo = F, warning = F, error=F, message = F, comment = F, cache=F)
library(nichenetr)
library(Seurat)
library(tidyverse)
library(knitr)
library(tidyr)
library(reshape2)
library(gridExtra)
library(ComplexHeatmap)
library(clusterProfiler)
library(RColorBrewer)
library(nichenetr)
library(plotly)
library(ggalluvial)
library(plotly)
library(stringr)
options(stringsAsFactors = F)
library(ParetoTI)


PrctCellExpringGene <- function(object, genes, group.by = "all"){
  if(group.by == "all"){
    prct = unlist(lapply(genes,calc_helper, object=object))
    result = data.frame(Markers = genes, Cell_proportion = prct)
    return(result)
  }
  
  else{        
    list = SplitObject(object, group.by)
    factors = names(list)
    
    results = lapply(list, PrctCellExpringGene, genes=genes)
    for(i in 1:length(factors)){
      results[[i]]$Feature = factors[i]
    }
    combined = do.call("rbind", results)
    return(combined)
  }
}

calc_helper <- function(object,genes){
  counts = object[['RNA']]@counts
  ncells = ncol(counts)
  if(genes %in% row.names(counts)){
    sum(counts[genes,]>0)/ncells
  }else{return(NA)}
}

####################
#### Parameters ####
####################
min.pct = 0.1# 0.25 # min fraction of cells that expressed a gene in order 
# for it to be considered in the targets of nichenet analysis

###########################
#### NicheNet Analysis ####
###########################
# https://github.com/saeyslab/nichenetr/blob/master/vignettes/ligand_activity_geneset.md
#This is a downstream analysis of single sell data that was generated by Seurat. 

# We used Nichenet databases to characterize which ligands might have 
# effected gene expression within two clusters/archetypes. 

lr_network = readRDS(url("https://zenodo.org/record/3260758/files/lr_network.rds"))
lr_network = lr_network %>% mutate(from = convert_human_to_mouse_symbols(from), to = convert_human_to_mouse_symbols(to)) %>% drop_na() 

ligand_target_matrix = readRDS(url("https://zenodo.org/record/3260758/files/ligand_target_matrix.rds"))
colnames(ligand_target_matrix) = ligand_target_matrix %>% colnames() %>% convert_human_to_mouse_symbols()
rownames(ligand_target_matrix) = ligand_target_matrix %>% rownames() %>% convert_human_to_mouse_symbols()

gr_network = readRDS(url("https://zenodo.org/record/3260758/files/gr_network.rds"))
gr_network = gr_network %>% mutate(from = convert_human_to_mouse_symbols(from), to = convert_human_to_mouse_symbols(to)) %>% drop_na()  

weighted_networks = readRDS(url("https://zenodo.org/record/3260758/files/weighted_networks.rds"))
weighted_networks$lr_sig = weighted_networks$lr_sig %>% mutate(from=convert_human_to_mouse_symbols(from), to=convert_human_to_mouse_symbols(to)) %>% drop_na()
weighted_networks$gr = weighted_networks$gr %>% mutate(from=convert_human_to_mouse_symbols(from), to=convert_human_to_mouse_symbols(to)) %>% drop_na()


# paths that need to be adapted to local paths
utils_path = "/Users/tudaga/Documents/github/BSSP_Pareto_cerebellum/ParetoTI_utils.R"
source(utils_path)

save_path = '/Users/tudaga/Documents/github/BSSP_Pareto_cerebellum/mouse_eyedata_lens_puck_190926_03/'

################
# if reading from .csv
csv_path = paste0(save_path, 'mouse_eyedata_lens_')
counts = read.csv(paste0(csv_path, 'counts_allgenes.csv'), sep = ",", header=FALSE)
counts = t(counts)
gene_names = read.csv(paste0(csv_path, 'gene_names_allgenes.csv'), sep = ",", header = FALSE)
clusters = read.csv(paste0(csv_path, 'clusters.csv'), sep = ",", header = FALSE)
data_sce = SingleCellExperiment(list(counts=counts))
rownames(data_sce) = as.character(gene_names[,1])
data_sce@colData['cluster'] = as.character(clusters[,1])
################
# if reading from .RDS
mli1_s = readRDS('/Users/tudaga/Documents/github/BSSP_Pareto_cerebellum/data//mli1_seurat.RDS')
mli1_s = UpdateSeuratObject(mli1_s)
mli1_sce = as.SingleCellExperiment(mli1_s)
###############

data_sce = scran::computeSumFactors(data_sce) 
data_sce = scater::logNormCounts(data_sce) 
data_sce = scater::runPCA(data_sce, ncomponents = 3, scale = T, exprs_values = "logcounts")

PCs4arch = t(reducedDim(data_sce, "PCA"))
cells_coords_kn = PCs4arch

noc = 3 # hard coded
arc_all = fit_pch(PCs4arch, volume_ratio = "t_ratio", maxiter = 500,
                  noc = noc, delta = 0, conv_crit = 1e-04)
p_pca = plot_arc(arc_data = arc_all, data = PCs4arch, 
                 which_dimensions = 1:3, line_size = 2.5,
                 data_lab = data_sce@colData$cluster,
                 text_size = 60, data_size = 2) 
plotly::layout(p_pca, title = paste0("Colored by subtype ident"))

arc_coords_ka = arc_all$XC
colnames(arc_coords_ka) = c("arc1", "arc2", "arc3")#, "arc4")
noc = length(colnames(arc_coords_ka))
npcs = 3
combined_coords_kn = cbind(arc_coords_ka[1:npcs,], cells_coords_kn[1:npcs,])
pairwise_dists = dist(t(combined_coords_kn))
pairwise_dists = as.matrix(pairwise_dists)
head(colnames(pairwise_dists))
dist_to_arc = pairwise_dists[-1*1:noc, colnames(arc_coords_ka)]
closest_arc = rep(NA, dim(dist_to_arc)[1])
for (i in 1:dim(dist_to_arc)[1]){
  closest_arc[i] = as.numeric(which(dist_to_arc[i,] == min(dist_to_arc[i,])))
}
p_pca = plot_arc(arc_data = arc_all, data = PCs4arch, 
                 which_dimensions = 1:3, line_size = 2.5,
                 data_lab = as.factor(closest_arc),
                 text_size = 60, data_size = 2) 
plotly::layout(p_pca, title = paste0("Colored by closest arc"))

data_sce@colData$closest_arc = as.factor(closest_arc)

# Find genes and gene sets enriched near vertices ####
# Map GO annotations and measure activities
logcounts(data_sce) = as.matrix(logcounts(data_sce))
counts(data_sce) = as.matrix(counts(data_sce))

activ = measure_activity(data_sce, # row names are assumed to be gene identifiers
                         which = "BP", return_as_matrix = F,
                         taxonomy_id = 10090, keytype = "ALIAS",
                         lower = 20, upper = 1000,
                         aucell_options = list(aucMaxRank = nrow(data_sce) * 0.1,
                                               binary = F, nCores = 1,
                                               plotStats = FALSE))

# Merge distances, gene expression and gene set activity into one matrix
data_attr = merge_arch_dist(arc_data = arc_all, data = PCs4arch, 
                            feature_data = as.matrix(logcounts(data_sce)),
                            colData = activ,
                            dist_metric = c("euclidean", "arch_weights")[1],
                            colData_id = "cells", rank = F) 

# Use Wilcox test to find genes maximally expressed in 10% closest to each vertex
enriched_genes = find_decreasing_wilcox(data_attr$data, data_attr$arc_col,
                                        features = data_attr$features_col,
                                        bin_prop = 0.1, method = "BioQC")

enriched_sets = find_decreasing_wilcox(data_attr$data, data_attr$arc_col,
                                       features = data_attr$colData_col,
                                       bin_prop = 0.1, method = "BioQC")

# Take a look at top genes and functions for each archetype
labs = get_top_decreasing(summary_genes = enriched_genes, summary_sets = enriched_sets,
                          cutoff_genes = 0.01, cutoff_sets = 0.05, 
                          cutoff_metric = "wilcoxon_p_val", 
                          p.adjust.method = "fdr",
                          order_by = "mean_diff", order_decreasing = T,
                          min_max_diff_cutoff_g = 0.4, min_max_diff_cutoff_f = 0.03)
# thresholds above are # hard coded

# With the code below we can ge a sense if we want to go back up and 
# change the thresholds to include more enriched genes
archetype = 'archetype_3' #4
sets_rows = labs[["enriched_sets"]]$x_name==archetype
print(labs[["enriched_sets"]][sets_rows, 2])
genes_rows = labs[["enriched_genes"]]$arch_name==archetype
enriched_genes_arc = labs[["enriched_genes"]]$genes[genes_rows]
print(enriched_genes_arc)

seurObj = as.Seurat(data_sce, counts = "counts", data = "logcounts")
table(seurObj@meta.data$closest_arc)
seurObj@active.ident = seurObj@meta.data$closest_arc

seurObj_s = seurObj

sender = '1' # hard coded
receiver = '3' # hard coded

# this is the way to define the GOIs as enriched at receiver
geneset_oi = labs[["enriched_genes"]]$genes[labs[[
  "enriched_genes"]]$arch_name==paste0('archetype_', receiver)]
# markers of receiver
print(paste0('There are ', length(geneset_oi), ' GOIs in total.'))

ligands = lr_network %>% pull(from) %>% unique()
receptors = lr_network %>% pull(to) %>% unique()
expressed_genes = c()
# this is the way to define the receiver based on closest archetype
receiver_lognormcounts = seurObj_s@assays$RNA@data[,seurObj_s$closest_arc==receiver]

expressed_genes_receiver = rownames(receiver_lognormcounts)[rowSums(receiver_lognormcounts)!=0]
# background are all the genes expressed in the receiver population that are not possible targets
background_expressed_genes = expressed_genes_receiver %>% .[. %in% rownames(ligand_target_matrix)]
# this is the way to define the sender based on closest archetype
sender_lognormcounts = seurObj_s@assays$RNA@data[,seurObj_s$closest_arc==sender]

expressed_genes_sender = rownames(sender_lognormcounts)[rowSums(sender_lognormcounts)!=0]
expressed_ligands = intersect(ligands,expressed_genes_sender)
expressed_receptors = intersect(receptors,expressed_genes_receiver)
potential_ligands = lr_network %>% filter(
  from %in% expressed_ligands & to %in% expressed_receptors) %>% pull(from) %>% unique()

print(paste0('There are ', length(potential_ligands), 
             ' potential ligands from sender ', sender, ' to receiver ', receiver, '.'))

ligand_activities = predict_ligand_activities(
  geneset = as.character(geneset_oi), 
  background_expressed_genes = background_expressed_genes, 
  ligand_target_matrix = ligand_target_matrix, 
  potential_ligands = potential_ligands)

dim(ligand_activities)

num_ligs = ceiling(0.2*dim(ligand_activities)[1])#20
best_upstream_ligands = ligand_activities %>% top_n(num_ligs, pearson) %>% arrange(-pearson) %>% pull(test_ligand)
head(best_upstream_ligands)

active_ligand_target_links_df = best_upstream_ligands %>% lapply(
  get_weighted_ligand_target_links,
  geneset = geneset_oi, 
  ligand_target_matrix = ligand_target_matrix, n = 250) %>% bind_rows()
nrow(active_ligand_target_links_df)
active_ligand_target_links_df
active_ligand_target_links_df = active_ligand_target_links_df[rowSums(is.na(active_ligand_target_links_df))==0, ]

active_ligand_target_links = prepare_ligand_target_visualization(
  ligand_target_df = active_ligand_target_links_df, 
  ligand_target_matrix = ligand_target_matrix, cutoff = 0)#0.25)

nrow(active_ligand_target_links)
head(active_ligand_target_links)

order_ligands = intersect(best_upstream_ligands, colnames(active_ligand_target_links)) %>% rev()
order_targets = active_ligand_target_links_df$target %>% unique()
vis_ligand_target = active_ligand_target_links[order_targets, order_ligands] %>% t()

p_ligand_target_network = vis_ligand_target %>% make_heatmap_ggplot(
  paste0("Prioritized archetype ", sender, " ligands"),
  paste0("Target genes in archetype ", receiver), 
  color = "purple",
  legend_position = "top", 
  x_axis_position = "top",
  legend_title = "Regulatory potential") + scale_fill_gradient2(
    low = "whitesmoke",  
    high = "purple", 
    breaks = c(0,0.005,0.01)) + theme(
      axis.text.x = element_text(face = "italic"))
p_ligand_target_network

# Visualize in 3D PC space
#gene_vec = c(order_ligands, order_targets)
gene_vec = c("Nlgn1", "Lim2")
print(gene_vec)
for (gene in gene_vec) {
  print(make_3d_pc_plot_gene(data_sce, arc_all, gene, 2.5, 2))
}

## Visualize receptors
expressed_genes = c(expressed_genes, expressed_genes_receiver)
best_upstream_ligands = active_ligand_target_links_df$ligand %>% unique()
best_upstream_receptors = lr_network %>% pull(to) %>% unique() %>% intersect(
  expressed_genes)

lr_network_top_df_long = weighted_networks$lr_sig %>% inner_join(
  lr_network %>% distinct(from, to), by = c("from","to"))  %>% drop_na() %>% filter(from %in% best_upstream_ligands & to %in% best_upstream_receptors)
lr_network_top_df = lr_network_top_df_long %>% spread("from","weight",fill = 0)
lr_network_top_matrix = lr_network_top_df %>% dplyr::select(-to) %>% as.matrix() %>% magrittr::set_rownames(lr_network_top_df$to)
receptor.expression.df = AverageExpression(seurObj_s, 
                                           features =unique(lr_network_top_df$to), 
                                           add.ident='closest_arc')[['RNA']]
receptor.expression.df = log10(1+receptor.expression.df)[sort(
  rownames(receptor.expression.df)),
  sort(colnames(receptor.expression.df))] %>% as.matrix()

p1 = lr_network_top_matrix %>% Heatmap(
  column_title = "Ligand-Receptor interaction potential and expression", 
  cluster_columns = F, show_row_names = F, show_column_names = T, 
  col=brewer.pal(4, 'Oranges'))
ha = HeatmapAnnotation(Cluster = colnames(receptor.expression.df))
p2 = Heatmap(receptor.expression.df, 
             cluster_columns = F, 
             show_column_names = F, 
             column_title = "Receptor Expression", 
             name="log10(Expression)", 
             row_order = row_order(p1), 
             top_annotation = ha)
p1+p2

# Alluvial plot
#This shows the connection (prior knoweledge), between ligands to all 
# receptors and targets that are in our GOI dataset.  
best_targets = active_ligand_target_links_df$target %>% unique()
gr_network_top_df_long = weighted_networks$gr %>% inner_join(
  lr_network %>% distinct(from, to), 
  by = c("from", "to")) %>% drop_na() %>% filter(
    from %in% best_targets & to %in% best_upstream_receptors)
colnames(lr_network_top_df_long) = c("ligand", "receptor", "lr")
colnames(gr_network_top_df_long) = c("target", "receptor", "rg")

print(best_targets)
print(best_upstream_receptors)









